# 1.什么是索引 index 

## 1.1.索引基本介绍

官方定义：一种帮助mysql提高查询效率的数据结构

## 1.2.索引的优缺点

优点：

1、大大加快数据查询速度
		缺点：

1. 维护索引需要耗盘数据库资源
2. 系引需要占用磁盘空间
3. 当对表的据进行增删改操作的时候,因为要维护索引，速度会受到影响

# 2.索引分类

## 2.1.InnoDB引擎索引

- **主键索引**
  设定为主键后数据库会自动建立索引，innodb为聚簇索引

- **单值索引**（除主键意外的列建的索引）
  即一个素引只包含单个列，一个表可以有多个单列素引

  例如我可以单独为name列创建一个索引，也可以为age列创建一个索引，他们都叫单值索引
  
  又可以称为 **普通索引** ，**单列索引**
  
- **唯一索引**
  索引列的值必须唯一，**但允许有空值且有且只有一个空值**

- **复合索引**
  即一个素引包含多个列

  基于多条件查询构建的索引比如为name,age两个列建一个索引，叫做复合索引

  ```sql
  select name,age form student where name and age
  ```


> **主键索引和唯一索引的区别**（面试经常考）
>
> 主键索引不允许有空值，唯一索引允许有空值，并且只能有一个空值

## 2.2.MyISAM引擎索引

- e.Full Text 全文秀引（MySql5.7版本之前只能用于MYISAM引擎）
  - 全文索引类型为FULLTEXT，在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引可以在CHAR、VARCHAR、TEXT类型列上创建。MYSOL只有MYISAM存储引第支持全文索引
# 3.索引的基本操作

## 3.1.主键索引创建和查看

```sql
-- 建表时，如果有主键则会自动创建主键索引
create table t_user(id varchar(20) primary key,name varchar(20));
-- 查看索引
show index from t_user;
```

查看表的索引，可以看到执行查看索引后为我们展示`t_user`表的索引的详细信息

![image-20210604002125758](https://gitee.com/codeluojay/TyproaImage/raw/master/images/image-20210604002125758.png)

`Table`：索引所在的表`t_user`

`Key_name`:索引名字为`PRIMARY`

`Column_name`:索引建立在哪个列上，建立在`id`列上

`Index_type`:B+树，虽然显示是`BTREE`但实际上是B+树

## 3.2.普通索引创建和查看

普通索引创建两种方式：建表时创建和建表之后创建

```sql
-- 建表之后创建  语法：create index 索引名 on 表名（列名）
create index name_index  on t_user(name);

```

![image-20210604004002549](https://gitee.com/codeluojay/TyproaImage/raw/master/images/image-20210604004002549.png)

可以看出相比主键索引的图多出一些东西

`Null`:是否允许空值，name所在列创建的索引时普通索引允许为空，所以是`YES`,主键列`id`是没有值

`Non_unique` ：索引能否包括重复，0是不可以包含重复，1是可以包含重复

`collation `:	列以什么方式存储在索引中，在mysql中，有值'A'（升序）或者NULL（无分类）

`cardinality `: 索引在唯一值的数据的估值,由于我们只是创建，没有添加数据，所以是0

```sql
-- 建表时创建的索引 语法：在列名名最后面，用key(列名)形式表示创建索引，创建多个索引以逗号隔开
create table t_user1(id varchar(20) primary key,name varchar(20),age int,key(name),key(age));
show index from t_user1;
```

![image-20210604004822021](https://gitee.com/codeluojay/TyproaImage/raw/master/images/image-20210604004822021.png)

建表时创建的索引其实有个不好的地方就是**不能指定索引的名字**，但是mysql会以列名作为索引名给我们创建普通索引

## 3.3.唯一索引创建和查看

唯一索引和普通索引类似也可以分为建表时创建和建表之后创建，只是关键字不同，普通索引关键字为`key(列名)`，唯一索引的关键字为`unique(列名)`

```sql
-- 唯一索引 建表时创建的索引
create table t_user2(id varchar(20) primary key,name varchar(20),age int,unique(name));
show index from t_user2;
```

![image-20210604005917180](https://gitee.com/codeluojay/TyproaImage/raw/master/images/image-20210604005917180.png)

查看唯一索引后来对照主键索引，可以看出区别：

`Non_unique`:索引能否包括重复,明显两者都是不能允许重复，所以都为0

`Null`:唯一索引可以为空是`YES`,主键索引不允许为空，所以不是`YES`

```sql
-- 唯一索引 建表后创建的索引 语法：create unique index 索引名 on 表名（列名）
create unique index age_index on t_user2(age);
show index from t_user2;
```

建表后再创建索引，则需要建索引时增加`unique`关键字在`index`前面，不然就是建立普通索引了。

## 3.4.复合索引创建和查看

复合索引和普通索引类似也可以分为建表时创建和建表之后创建，只是关键字`key(列名)`包含的列名不同，普通索引（单值索引）能有单个列`key(列名1)`，复合索引能有多个列`key(列名1，列名2)`

```sql
-- 复合索引 建表时创建的索引
create table t_user3(id varchar(20) primary key,name varchar(20),age int,key(name,age));
show index from t_user3;
```

![image-20210604012210546](https://gitee.com/codeluojay/TyproaImage/raw/master/images/image-20210604012210546.png)

建立复合索引的时候又可以和主键进行比较了。

首先复合索引名为`name`建立在`name`和`age`两个列上，所以图中`Column_name`中的`name`和`age`它们两的索引名字也就是`Key_name`都为`name`。`Non_unique`和`null`这两个不同就不再赘述了。

还有一个关键字`Seq_in_index`，在`name`和`age`上是1和2，这是表示它们在`name`这个序列中的顺序排列，`name`排在第一，`age`排在第二。而主键索引`id`，只有一个列，所以`Seq_in_index`为1。

```sql
-- 复合索引 建表后创建的索引
create index age_index on t_user3(name,age);
show index from t_user3;
```

> 复合索引有一道经典的面试题：
>
> ```sql
> -- 创建name,age,sex三个复合索引
> create table t_user4(id varchar(20) primary key,name varchar(20),age int,sex tinyint,key(name,age,sex));
> ```

```markdown
问题：
1. name,age,sex 能否走索引
2. name,sex,age 能否走索引
3. age,sex 能否走索引
4. sex,age,name 能否走索引
5. bir,age 能否走索引
考点：
1.最左前缀匹配原则 
2.mysql引擎在查询为了史了史好利用索引在查询过程中会动态调整查询字段顺序以便利用索引
```

首先1肯定可以，然后如果按照考点1最左前缀匹配原则，也只有1能走索引

但是在mysql引擎在查询为了更好利用索引，在查询过程中会动态调整查询字段顺序以便利用索引，比如`name,sex,age`和`sex,age,name`会优化成`name,age,sex`,这样就能符合最左前缀匹配原则，所以1,2,4都能走索引

但是3和5无论怎么优化和调换顺序，都不匹配最左前缀匹配原则，所以是不走索引的。

# 4.索引的底层原理

讲述索引的底层原理的时候，先建一张表和表的数据，需要注意的是建表的时候注意观察建表和插入数据的SQL语句。

1. 没有建额外的索引只有默认MySQL自带的主键索引
2. 插入的数据SQL语句中，插入的顺序是无序的，没有按照id升序插入

```sql
--建表
create table t_emp(id int primary key,name varchar(20),age int);
--插入数据
insert into t_emp values(5,'d',22);
insert into t_emp values(6,'d',22);
insert into t_emp values(7,'e',21);
insert into t_emp values(1,'a',23);
insert into t-emp values(2,'b',26);
insert into t_emp values(3,'c',27);
insert into t_emp values(4,'a',32);
insert into t_emp values(8,'f',53);
insert into t_emp values(9,'v',13);
-- 查询索引
show index from t_emp;
```

![image-20210605132051318](https://gitee.com/codeluojay/TyproaImage/raw/master/images/image-20210605132051318.png)

## 4.1.思考问题

但是我们查询所有数据后发现

![image-20210605132303528](https://gitee.com/codeluojay/TyproaImage/raw/master/images/image-20210605132303528.png)

插入的数据前是无序插入的，但是插入后的数据竟然按照`id`自然升序的形式拍好顺序放置在数据表中，原因就是因为新建数据库的时候有主键，mysql会自动为主键创建索引，主键索引进行排序了。

那么主键索引为什么要把数据拍好序？因为日后搜索就可以按照id顺序快速定位查询，避免逐行比较查找搜索定位。

主键索引怎么去做排序的呢？这就需要讲一下一条数据在底层存储的结构形式。

## 4.2.索引的数据结构

### 4.2.1索引如何保存行数据

以`insert into t_emp values(1,'a',23);`为例子，画了一下底层的存储结构。

![image-20210605133813185](https://gitee.com/codeluojay/TyproaImage/raw/master/images/image-20210605133813185.png)

每一条数据插入在底层都会被分成三个部分存储，**最左边是存储`id`的值**，**中间存储的主要的数据**、**右边是存储指针（也就是地址引用）**。

虽然我们插入的是无序，但是底层的索引会帮助我们构建一个有序的列表。也就是插入完`id`为1的数据后会紧着插入`id`为2的数据。

并且每一条数据都会通过最右边的指针链接起来,`id`为1的指针会指向`id`为2的数据，`id`为2的指针会指向`id`为3的数据，这样依次链接起来。

![image-20210605134859530](https://gitee.com/codeluojay/TyproaImage/raw/master/images/image-20210605134859530.png)

### 4.2.2索引如何优化数据查询

好家伙，这不有点类似链表的数据结构，那么问题来了，如果我要查id为`1000`的，如果按照链表的指针去找，那不就是要找1000次？

也就是说时间复杂度为`O(n)`,这其实是很慢的了？那怎么办呢？MySQL官方又想到优化的办法。

把排好序的存储结构按照**页**的存储单元结构概念去存储，简单来说就是分页存储这些排好序的数据结构。

比如1-3的数据分在第一页。4-6的数据分在第二页，每一页的数据大小是默认的16KB（前提是在InnoDB引擎下）。

![image-20210605140200567](https://gitee.com/codeluojay/TyproaImage/raw/master/images/image-20210605140200567.png)

那这只是分页呀，也没多大优化，跟没分页也没多大优化呀，在这基础上，MySQL还做了一个页的目录结构优化。

页目录基本存储单元存储的是每一页的第一个的数据的索引的`id`和指向第一页指针，那么上面的图又可以优化成下面形式。

![image-20210605141307835](https://gitee.com/codeluojay/TyproaImage/raw/master/images/image-20210605141307835.png)

这样我们再来查`id`为7的数据时，先去页目录里面先判断7跟1比较，然后4跟7比较，最后发现7落在7的页面录模块。这样就减少查询次数，原先要查7次，这下就查3次。那么对应的要查id为1000的数据，优化的效率也是**提升了一半的速度**。

需要注意上面只是画出**一个页目录**，在页目录的行中也会存在多个类似上面的页目录结构，并且每个页目录的结构大小也是16kb大小。

那么可能一层的节目录的结构还可能存储不是很多的数据，还有两层到三层页目录。一般到三层就已经存储到很多的数据了。

举个例子说明，假设还是以上面的建表语句和插入的数据为例

```sql
--建表
create table t_emp(id int primary key,name varchar(20),age int);
--插入数据
insert into t_emp values(5,'d',22);
```

最小基本的存储结构

![image-20210605133813185](https://gitee.com/codeluojay/TyproaImage/raw/master/images/image-20210605133813185.png)

主键为int类型4个字节，数据为name+age，为24个字节，指针一般大小在4到8个字节，去最大值8个字节计算。

每行数据对应最小基本单元的存储结构的大小：4+24+8 = 36 字节

每个叶子节点能存储的数据（页目录） ：16*1024/36 = 455个

上层每个页目录基本单元存储结构的大小：4+8 = 12个字节

上层每个页目录能存储的数据：16*1024/12 =1,365.33个

所以两层能存储数据大小：四舍五入为1,365.33*455 ≈621227个

如果三层目录结构：1,365.33*621227 ≈847974855（8亿个数据）

## 4.4.索引完整的示意图和计算过程



![image-20210526011113194](https://gitee.com/codeluojay/TyproaImage/raw/master/images/image-20210605154102986.png)

## 4.3.B树和B+树的区别

B+Tree是在B-Tree（B树）基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。

B树和B+树最大的区别在于B树非叶子节点要存数据，而B+树只有叶子节点才存数据

Mysql设计的时候为了减少基本只做两次磁盘IO，最顶层根节点是常驻内存，这样就保证基本只做两次磁盘IO。

基于主键索引查询，三层B+树一般只动两次磁盘IO

基于普通索引，一般要动三次磁盘IO，因为要基于普通索引找到主键，再根据主键用主键索引查询，所以是三次。（术语叫做回表操作）

从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。

在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。

B+Tree相对于B-Tree有几点不同：

1. 非叶子节点只存储键值信息。
2. 所有叶子节点之间都有一个链指针。
3. 数据记录都存放在叶子节点中。

InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，

也就是说一个页（B+Tree中的一个节点）中大概存储16KB/（8B+8B）=1K个键值（因为是估值，为方便计算，这里的K取值为10^3。^  也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3=10亿条记录。


实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2-4层。mysql的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。

# 5.聚簇索引和非聚簇索引

聚猴索引：将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据

非聚簇索引：将数据与索引分开存储，素引结构的叶子节点指向了数据对应的位置

## 5.1.辅助索引

注意在innodb中，在聚簇索引之上创建的索引称之为辅助索引，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引。辅助索引叶子节点存储的不再是行的物理位置，而是主键值，辅助索引访问数据总是需要二次查找。

![image-20210605154102986](https://gitee.com/codeluojay/TyproaImage/raw/master/images/image-20210605154102986.png)



## 5.2.聚簇索引的实现之一主键索引

聚簇索引在mysql表中通常为主键索引，对于那些建表时没有主键，它会像ORACLE生成一个自增ID，去建一个聚簇索引，底层也是排序。

为什么mysql的主键为int类型，就是因为int类型比较好排序，而主键用uuid生成的字符串比较离散，不容易排序。

**主键索引一定是聚簇索引，但是聚簇索引不一定是主键索引**

因为普通索引也可以做到将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据，它是聚簇索引同时是普通索引，并不是主键索引。

## 5.3.聚簇索引索引为什么存储指针地址值

为什么回表查找的时候记录的是主键值，而不是指针的地址值？

因为数据的增删改操作会改变链表的地址值，不存储聚簇索引地址值，需要额外维护，浪费内存。

## 5.4.使用聚簇索引的优势

思考问题：每次使用辅助索引检索都要经过两次B+树查找，看上去聚旅索引的效率明显要低于非聚簇索引，这不是多此一举吗？聚旅索引的优势在哪？

1.由于行数据和聚蒸索引的叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加就到了Buffer中（缓存器），再次访问时，会在内存中完成访问，不必访问磁盘。

这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。

举个例子：

Innodb中如果使用聚簇索引第一次查询页id为1的数据，就会页id为1的所有数据加载到内存缓存中，第二次查询id为2的数据时直接找缓存要数据，不需要磁盘IO。而MyISAM中因为叶子节点存放的不是物理地址，每次都要动磁盘IO

2.辅助索引的叶子节点，存储主键值，而不是数据的存放地址。

好处是当行数据放生变化时，索引树的节点也需要分裂变化；或者是我们需要查找的数据，在上一次IO读写的缓存中没有，需要发生一次新的IO操作时，可以避免对辅助索引的维护工作，只需要维护聚索引树就好了。

另一个好处是，因为辅助索引存放的是主键值，减少了辅助索引占用的存储空间大小。

## 5.5.聚簇索引需要注意什么？

### 5.5.1.主键索引不要使用UUID

当使用主键为聚簇索引时，主键最好不要使用uuid，因为uuid的值太过离散，不适合排序且可能出线新增加记录的uuid，会插入在索引树中间的位置，导致索引树调整复杂度变大，消耗更多的时间和资源。

建议使用int类型的自增，方便排序并且默认会在索引树的末尾增加主键值，对索引树的结构影响最小。而且，主键值占用的存储空间越大，辅助索引中保存的主键值也会跟着变大，占用存储空间，也会影响到Io操作读取到的数据量。

### 5.5.2.为什么主键通常建议使用自增id

聚猴索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。

如果主键不是自增id，那么可以想象，它会干些什么，不断地调整数据的物理地址、分页，当然也有其他一些措施未减少这些操作，但却无法彻底避免。

但如果是自增的，那就简单了，它只需要一页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。

# 6.什么情况下无法利用索引呢？

（面试会经常基于这三条去变形出面试题）

1.查询语句中使用LIKE关键字

在查询语句中使用LIKE关键字进行查询时，如果匹配字符串的第一个字符为"%"，索引不会被使用。如果%"不是在第一个位置，素引就会被使用。

2.查询语句中使用多索引

多列索引是在表的多个字段上创建一个秦引，只有查询条件中使用了这些字段中的第一个字段，索引才会被使用。

3.查询语句中使用OR关键字

查询语句只有0R关键字时，如果0R前后的两个条件的列都是索引（单列索引和符合索引都可以），那么查询中将使用索引。如果OR前后有一个条件的列不是索引，那么查询中将不使用索引。

举个例子：

```
有单列索引(两个) name,age
name and age （肯定可以）
name or age（也可以）
name or age or bir（不可以）
```

